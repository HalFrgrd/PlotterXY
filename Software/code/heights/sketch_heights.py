import vsketch
import numpy as np


import numpy as np


def interpolant(t):
    return t*t*t*(t*(t*6 - 15) + 10)


def generate_perlin_noise_2d(
        shape, res, tileable=(False, False), interpolant=interpolant
):
    """Generate a 2D numpy array of perlin noise.

    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multple of res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            res.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).

    Returns:
        A numpy array of shape shape with the generated noise.

    Raises:
        ValueError: If shape is not a multiple of res.
    """
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
             .transpose(1, 2, 0) % 1
    # Gradients
    angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    if tileable[0]:
        gradients[-1,:] = gradients[0,:]
    if tileable[1]:
        gradients[:,-1] = gradients[:,0]
    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
    g00 = gradients[    :-d[0],    :-d[1]]
    g10 = gradients[d[0]:     ,    :-d[1]]
    g01 = gradients[    :-d[0],d[1]:     ]
    g11 = gradients[d[0]:     ,d[1]:     ]
    # Ramps
    n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
    n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
    n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
    n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
    # Interpolation
    t = interpolant(grid)
    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
    return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)


def generate_fractal_noise_2d(
        shape, res, octaves=1, persistence=0.5,
        lacunarity=2, tileable=(False, False),
        interpolant=interpolant
):
    """Generate a 2D numpy array of fractal noise.

    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multiple of lacunarity**(octaves-1)*res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            (lacunarity**(octaves-1)*res).
        octaves: The number of octaves in the noise. Defaults to 1.
        persistence: The scaling factor between two octaves.
        lacunarity: The frequency factor between two octaves.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The, interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).

    Returns:
        A numpy array of fractal noise and of shape shape generated by
        combining several octaves of perlin noise.

    Raises:
        ValueError: If shape is not a multiple of
            (lacunarity**(octaves-1)*res).
    """
    noise = np.zeros(shape)
    frequency = 1
    amplitude = 1
    for _ in range(octaves):
        noise += amplitude * generate_perlin_noise_2d(
            shape, (frequency*res[0], frequency*res[1]), tileable, interpolant
        )
        frequency *= lacunarity
        amplitude *= persistence
    return noise


class HeightsSketch(vsketch.SketchClass):
    # Sketch parameters:
    NUM_X_PERIODS = vsketch.Param(8)
    NUM_Y_PERIODS = vsketch.Param(5)
    amplitude_1 = vsketch.Param(5.0)

    xDisplacementFactor = vsketch.Param(0.0)

    def draw(self, vsk: vsketch.Vsketch) -> None:
        vsk.size("a4", landscape=True)
        vsk.scale("mm")

        # implement your sketch here
        # vsk.circle(0, 0, self.radius, mode="radius")

        
        NUM_POINTS_X = 1000 // self.NUM_X_PERIODS * self.NUM_X_PERIODS
        NUM_POINTS_Y = 160 // self.NUM_Y_PERIODS * self.NUM_Y_PERIODS

        noise = generate_perlin_noise_2d((NUM_POINTS_X,NUM_POINTS_Y),(self.NUM_X_PERIODS,self.NUM_Y_PERIODS))
        def drawWithAmplitude(amplitude):
            linesToDraw = []

            for y in range(NUM_POINTS_Y):
                # oldX, oldY = 0, y
                # for x in range(1,100):
                #     vsk.line(oldX, oldY, x,y)
                #     oldX = x

                ys = np.array([y]*NUM_POINTS_X,dtype=np.float32)
                xs = np.arange(NUM_POINTS_X,dtype=np.float32)
                yDisplacement = self.getHeightDisplacement(y,noise)
                yDisplacement = yDisplacement * amplitude
                ys += yDisplacement
                xDisplacement = (yDisplacement)*self.xDisplacementFactor # this messes up the occlusion
                xs+= xDisplacement

                linesToDraw.append((xs,ys))
            
            # Draw the lines starting at the bottom of the page
            # We keep track of how far up the page we've drawn
            # And split a line if it is being occluded
            minYValuesSoFar = np.float32(np.inf)
            for (xs,ys) in linesToDraw[::-1]:
                minYValuesSoFar = np.minimum(ys,minYValuesSoFar)
                
                cond = ys <= minYValuesSoFar

                subLinesYs = np.split(ys[cond], np.where(np.diff(np.where(cond)[0]) > 1)[0] + 1)
                subLinesXs = np.split(xs[cond], np.where(np.diff(np.where(cond)[0]) > 1)[0] + 1)
                
                for subXs, subYs in zip(subLinesXs,subLinesYs):
                    vsk.polygon(subXs*0.26,subYs)

        drawWithAmplitude(self.amplitude_1)
        vsk.stroke(3)
        # drawWithAmplitude(5)
        # vsk.stroke(10)
        # drawWithAmplitude(6)


    def getHeightDisplacement(self, y, noise):
        yNoise = noise[:,y]
        return np.sin(( 0.5*yNoise**2 + yNoise) *5)#*(noise[:,y] + 1 + noise[:,y]**2 * 0.5)


    def finalize(self, vsk: vsketch.Vsketch) -> None:
        vsk.vpype("linemerge linesimplify reloop linesort")


if __name__ == "__main__":
    HeightsSketch.display()
